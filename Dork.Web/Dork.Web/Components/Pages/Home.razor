@page "/"
@rendermode InteractiveServer
@using Dork.Engine.Game
@inject DorkGame Game
@inject IJSRuntime JS

<div class="dork-shell">
    <div class="dork-header">
        <div class="dork-title">DORK</div>
        <div class="dork-subtitle">A text adventure that judges your input.</div>
    </div>

    <div class="dork-output" @ref="_outputDiv">
        @foreach (var line in _history)
        {
            <div class="@line.Css">
                @((MarkupString)line.Html)
            </div>
        }
    </div>

    <div class="dork-inputrow">
        <span class="dork-prompt">&gt;</span>
        <input class="dork-input"
               @bind="_input"
               @bind:event="oninput"
               @onkeydown="OnKeyDown"
               placeholder="Type a command, make a mistake."
               autocomplete="off" />
        <button class="dork-btn" @onclick="Submit">Do it</button>
    </div>

    <div class="dork-hints">
        Try: <code>look</code>, <code>go out</code>, <code>take phone</code>, <code>inv</code>
    </div>
</div>

@code
{
    private string _input = "";
    private ElementReference _outputDiv;

    private readonly List<Line> _history = new();

    private readonly List<string> _cmdHistory = new();
    private int _historyIndex = -1; // -1 means "not browsing"
    private CancellationTokenSource? _snarkCts;


    protected override void OnInitialized()
    {
        // Initial "look"
        AppendSystem(Game.Execute("look").Text);
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await Submit();
            return;
        }

        if (e.Key == "ArrowUp")
        {
            if (_cmdHistory.Count == 0) return;

            if (_historyIndex == -1) _historyIndex = _cmdHistory.Count - 1;
            else _historyIndex = Math.Max(0, _historyIndex - 1);

            _input = _cmdHistory[_historyIndex];
            return;
        }

        if (e.Key == "ArrowDown")
        {
            if (_cmdHistory.Count == 0) return;

            if (_historyIndex == -1) return;

            _historyIndex = Math.Min(_cmdHistory.Count, _historyIndex + 1);
            _input = _historyIndex >= _cmdHistory.Count ? "" : _cmdHistory[_historyIndex];
            return;
        }
    }

    private async Task Submit()
    {
        _snarkCts?.Cancel();
        _snarkCts = new CancellationTokenSource();

        var cmd = _input?.Trim() ?? "";
        if (cmd.Length == 0) return;

        _cmdHistory.Add(cmd);
        _historyIndex = -1;

        AppendUser(cmd);
        _input = "";

        var result = Game.Execute(cmd);

        if (result.ErrorCode == "UNPARSEABLE")
        {
            try
            {
                await FakeThinkAndReject(_snarkCts.Token);
            }
            catch (TaskCanceledException)
            {
                // user did something else; good for them
            }
        }
        else
        {
            AppendSystem(result.Text, isError: result.IsError);
        }

        await ScrollToBottom();
    }

    private async Task FakeThinkAndReject(CancellationToken token)
    {
        AppendSystem("Considering your request...");
        await Task.Delay(350, token);

        AppendSystem("Contemplating actions...");
        await Task.Delay(350, token);

        AppendSystem("Evaluating response from system...");
        await Task.Delay(350, token);

        AppendSystem("Yeah, just no.", isError: true);
    }

    private void AppendUser(string text)
        => _history.Add(new Line(HtmlEncode(text), "dork-line dork-user"));

    private void AppendSystem(string text, bool isError = false)
        => _history.Add(new Line(HtmlEncode(text).Replace("\n", "<br />"), isError ? "dork-line dork-error" : "dork-line dork-system"));

    private async Task ScrollToBottom()
    {
        await JS.InvokeVoidAsync("dorkScrollToBottom", _outputDiv);
    }

    private static string HtmlEncode(string s)
        => System.Net.WebUtility.HtmlEncode(s);

    private sealed record Line(string Html, string Css);
}
